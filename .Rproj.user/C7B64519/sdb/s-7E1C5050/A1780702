{
    "collab_server" : "",
    "contents" : "streamGaussian <- function(\n  x.new=x.new, my=list(), \n  eta.fixed=NA, eta.min=0.001, eta.max=0.3, \n  alpha=0.001,\n  lambda.fixed=NA, lambda.min=0.7, lambda.max=0.999,\n  efficient=FALSE, scaleit=FALSE, \n  covFix=NULL, muFix=NULL # helper options for LDA\n){\n  \n  ## x.new must be a vector\n  ## params must be a list\n  \n  p = length(x.new); \n  \n  ## INITIALISATIONS if t=0\n  if (length(my)==0){\n    \n    \n    \n    ## primary initialisations\n    v.0 <- 10\n    nn = 1\n    mu <- rep(0,p) \n    if (!is.null(muFix)){\n      mu <- muFix\n    } \n    S <- diag(v.0,p,p)\n    if (!is.null(covFix)){\n      S <- covFix\n    }\n    invS <- diag(1/v.0,p,p)\n    ldS <- p*log(v.0) \n    J <- 0\n    \n    # gradients\n    mug <- rep(0,p)\n    Sg <- matrix(0,p,p)\n    invSg <- matrix(0,p,p) \n    ldSg <- 0 \n    Jg <- 0 \n    \n    ## if adaptive forgetting, lambda=lambda.max, else lambda=lambda.fixed \n    \n    if (is.na(eta.fixed)){\n      eta <- eta.min\n      lambda <- lambda.max\n    } else {\n      eta <- eta.fixed\n      lambda <- lambda.fixed\n    }\n    \n    \n    my <- list(\n      mu = mu, S = S, invS = invS, ldS = ldS, J = J,\n      mug=mug, Sg=Sg, invSg=invSg, ldSg=ldSg, Jg=Jg,\n      eta=eta, lambda = lambda\n    )\n    \n  }\n  \n  \n  ## COMPUTE GRADIENT \n  J = my$ldS + t(x.new - my$mu)%*%my$invS%*%(x.new - my$mu)\n  Jg = my$ldSg -2*t(x.new-my$mu)%*%(my$invS)%*%(my$mug) + t(x.new-my$mu)%*%my$invSg%*%(x.new-my$mu)\n  if (scaleit) {Jg = (1/J)*Jg}\n  \n  ## PARAMETER UPDATES\n  if (!is.null(muFix)){\n    mug = rep(0,p)\n    mu = muFix\n  } else {\n    mu = my$mu + my$eta*(x.new - my$mu)\n    mug = (1-my$eta)*my$mug +(x.new-my$mu);    \n  }\n  \n  if (!is.null(covFix)){\n    S = covFix\n    Sg = 0*diag(p)\n  } else {\n    S = (1-my$eta)*my$S + my$eta*((x.new-mu)%*%t(x.new-mu))\n    Sg = (1-my$eta)*my$Sg -my$S + (x.new-mu)%*%t(x.new-mu) + \n      my$eta*( -mug%*%t(x.new-mu) - (x.new-mu)%*%t(mug))\n    \n    #Pi = my$Pi + my$eta*(x.new%*%t(x.new) - my$Pi) \n    #Pig = (1-my$eta)*my$Pig +(x.new%*%t(x.new)-my$Pi);\n    \n    #S = Pi - mu%*%t(mu)\n    #Sg = Pig - mug%*%t(mu) - mu%*%t(mug)\n    \n  }\n  \n  \n  \n  \n  \n  if (efficient){\n    ### NOT CHECKED YET !!!!!!\n    # auxillary quantities gamma, h and their gradients\n    g = (n-1)^2/n + t(x.new-mu)*my$invS*(x.new-mu)\n    gg = ng*(n-1)*(n+1)/n^2+t(x.new-mu)*my$invSg*(x.new-mu)-2*t(x.new-mu)*my$invS*mug;\n    \n    h = my$invS*(x.new-mu)*t(x.new-mu)*my$invS;\n    hg = my$invSg*(x.new-mu)*t(x.new-mu)*my$invS+my$invS*(x.new-mu)*t(x.new-mu)*my$invSg;\n    hg = hg - my$invS*mug*t(x.new-mu)*my$invS- my$invS*(x.new-mu)*t(mug)*my$invS;\n    \n    # inv(sigma) and log(det(sigma)), updated efficiently\n    invSg = -(ng/(n-1)^2)*(my$invS-(1/g)*h)+(n/(n-1))*(my$invSg+(gg/g^2)*h-(1/g)*hg);\n    invS = (n/(n-1))*(my$invS -(1/g)*h);\n    \n    ldS = (p-2)*log(n-1)+ (1-p)*log(n)+log(g)+my$ldS;\n    ldSg = (p-2)*ng/(n-1) + (1-p)*ng/n + gg/g+my$ldSg;\n  } else {\n    # inv(sigma) and log(det(sigma)), updated explicitly\n    \n    invS = solve(S)\n    ldS = log(det(S));  \n    \n    \n    invSg = -invS%*%Sg%*%invS;\n    ldSg = sum(diag(invS%*%Sg));\n  }\n  \n  \n  # update lambda\n  if (is.na(eta.fixed)){\n    eta = my$eta - alpha*Jg/p;\n  } else {eta = my$eta}\n  eta = min(eta,eta.max);\n  eta = max(eta,eta.min);\n  \n  # return updated parameters\n  \n  my <- list(\n    mu = mu, S = S, invS = invS, ldS = ldS, J = J,\n    mug=mug, Sg=Sg, invSg=invSg, ldSg=ldSg, Jg=Jg,\n    eta=eta\n  )\n  \n  \n  \n  \n  return(my)\n}\n",
    "created" : 1501363718909.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2225410290",
    "id" : "A1780702",
    "lastKnownWriteTime" : 1501366593,
    "last_content_update" : 1501366593408,
    "path" : "~/libraries/smle/R/library_gaussian.R",
    "project_path" : "R/library_gaussian.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}