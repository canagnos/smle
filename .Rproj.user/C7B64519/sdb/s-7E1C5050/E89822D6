{
    "collab_server" : "",
    "contents" : "update.LDA <- function(\n  x.new, c.new, paramsLDA, alpha=0.001\n){\n  # currently only supporting two classes\n  stopifnot(is.element(c.new,c(1,2)))\n  \n  p <- length(x.new)\n  # initialise\n  if (length(paramsLDA)==0){\n    paramsLDA <- list(\n      cone=list(),\n      ctwo=list(),\n      poolcov=list(),\n      prior=list()\n    )\n  }\n  \n  # update prior\n  paramsLDA$prior <- streamMultinomial(c.new, paramsLDA$prior, alpha = alpha)\n  \n  # update class-conditionals, holding covariance fixed to the pool estimate\n  if (length(paramsLDA$poolcov)==0){\n    covFix <- diag(p)  \n  } else {\n    covFix <- paramsLDA$poolcov$S\n  }\n  paramsLDA[[c.new]] <- streamGaussian(x.new, paramsLDA[[c.new]], alpha=alpha, covFix=covFix)\n  \n  # update pooled covariance, holding mean fixed to the resp. class-cond\n  if (length(paramsLDA[[c.new]])==0){\n    muFix <- rep(0,p)\n  } else {\n    muFix <- paramsLDA[[c.new]]$mu\n  }\n  paramsLDA$poolcov <- streamGaussian(X[i,], paramsLDA$poolcov, alpha=alpha/10, muFix=muFix)\n  \n  return(paramsLDA)\n}\n\n\n\nclassify.LDA <- function(\n  x.new, paramsLDA\n){\n  p <- length(x.new)\n  Js <- rep(NA,2)\n  \n  ldS <- paramsLDA[[3]]$ldS\n  invS <- paramsLDA[[3]]$invS\n  stopifnot(!is.null(ldS))\n  stopifnot(!is.null(invS))\n  mu1 <- paramsLDA[[1]]$mu\n  mu2 <- paramsLDA[[2]]$mu\n  if (is.null(mu1)){mu1 <- rep(0,p)}\n  if (is.null(mu2)){mu2 <- rep(0,p)}\n  pmu <- paramsLDA[[4]]$mu\n  \n  J1 <- 0.5*(ldS + t(x.new - mu1) %*% invS %*% (x.new - mu1))\n  J2 <- 0.5*(ldS + t(x.new - mu2) %*% invS %*% (x.new - mu2))\n  score <- J1-log(pmu[1])-(J2-log(pmu[2]))\n  if (score > 0){\n    chat <- 2  \n  } else {\n    chat <- 1\n  }\n  return(list(chat=chat,score=score))\n}\n\nstreamMultinomial <- function(\n  c.new=c.new, my=list(), \n  eta.fixed=NA, eta.min=0.0001, eta.max=0.3, alpha=0.001\n){\n  k = 2 # we only work with binomial for now\n  stopifnot(is.element(c.new,1:k))\n  \n  \n  \n  ## INITIALISATIONS if t=0\n  if (length(my)==0){\n    ## primary initialisations\n    mu <- rep(1,k)/k\n    J <- 0\n    # gradients\n    mug <- rep(0,k)\n    Jg <- 0 \n    \n    ## if adaptive forgetting, lambda=lambda.max, else lambda=lambda.fixed \n    if (is.na(eta.fixed)){\n      eta <- eta.min\n    } else {\n      eta <- eta.fixed\n    }\n    \n    my <- list(\n      mu = mu, J = J,\n      mug=mug, Jg=Jg,\n      eta=eta\n    )\n    \n  }\n  J <- 0\n  Jg <- -sum(my$mug * (as.numeric(c.new==1:k)/my$mu-1));  \n  \n  mu <- (1-my$eta) * my$mu + my$eta * as.numeric(c.new==1:k)\n  mug <- (1-my$eta) * my$mug + (as.numeric(c.new==1:k)-my$mu)\n  \n  \n  \n  # update lambda\n  if (is.na(eta.fixed)){\n    eta = my$eta - alpha*Jg;\n  } else {eta = my$eta}\n  eta = min(eta,eta.max);\n  eta = max(eta,eta.min);\n  \n  # return updated parameters\n  \n  my <- list(\n    mu = mu, J = J,\n    mug=mug, Jg=Jg,\n    eta=eta\n  )\n  \n  return(my)\n}\n\n\nKL <- function(mu0,mu1,S0,S1){\n  \n  \n  ## check dimensions\n  if (!is.matrix(S1)) {\n    S1 <- matrix(S1)\n  }\n  if (nrow(S1) != ncol(S1)) {\n    stop(message = \"S1 not square.\\n\")\n  }\n  if (!is.matrix(S0)) {\n    S0 <- matrix(S0)\n  }\n  if (nrow(S0) != ncol(S0)) {\n    stop(message = \"S0 not square.\\n\")\n  }\n  if (any(dim(S0) != dim(S1))){\n    stop(message = \"S1 and S0 have different dimensions\\n\")\n  }\n  if (!is.matrix(mu1)){\n    mu1 <- as.matrix(mu1)\n  }\n  if (!is.matrix(mu0)){\n    mu0 <- as.matrix(mu0)\n  }\n  if (nrow(mu1)!=nrow(S1)){\n    stop(message = \"mu1 does not have the right dimensions (must be px1)\\n\")\n  }\n  if (nrow(mu0)!=nrow(S0)){\n    stop(message = \"mu1 does not have the right dimensions (must be px1)\\n\")\n  }\n  \n  d <- nrow(S1)\n  \n  KL <- sum(diag(solve(S1)%*%S0)) + t(mu1-mu0) %*% solve(S1) %*% (mu1-mu0) - d - log(det(S0)/det(S1))\n  \n  \n  return(KL)\n}\n\ngenAbrupt <- function(\n  n=1000, \n  p=2,\n  muW=n/4, \n  covW=muW, \n  muSpread=10,\n  covSpread=2*p, \n  seed=1\n){\n  if (!is.na(seed)){\n    set.seed(seed)\n  }\n  if (is.na(covW)){covW <- n+1}\n  if (is.na(muW)){muW <- n+1}\n  mutrue <- matrix(NA,n,p)\n  X <- matrix(NA,n,p)\n  vartrue <- list()\n  KLtrue <- rep(NA,n)\n  \n  for (i in 1:n){\n    if (i%%covW == 1){\n      vartrue[[i]] <- rWishart(1, covSpread, (1/covSpread)*diag(p))[,,1]     \n    } else {\n      vartrue[[i]] <- vartrue[[i-1]]\n    }\n    if (i%%muW == 1){\n      mutrue[i,] <- rnorm(p,0,muSpread)  \n    } else {\n      mutrue[i,] <- mutrue[i-1,]      \n    }\n    if (i > 1){\n      KLtrue[i] <- KL(mutrue[i,],mutrue[i-1,],vartrue[[i]],vartrue[[i-1]])  \n    }\n    X[i,] <- chol(vartrue[[i]]) %*% rnorm(p,0,1) + mutrue[i,]\n     \n  }\n  #cat('Avg KL at change:',)\n  groundTruth <- list(\n    mutrue=mutrue, vartrue=vartrue, KLtrue=KLtrue\n  )\n  \n  return(list(X=X,groundTruth=groundTruth))\n}\n",
    "created" : 1501349146459.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2398646384",
    "id" : "E89822D6",
    "lastKnownWriteTime" : 1501366401,
    "last_content_update" : 1501366401799,
    "path" : "~/libraries/smle/R/library.R",
    "project_path" : "R/library.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}